import rclpy
from rclpy.node import Node
import threading
import sys
import select
import time

from .voice_interface import VoiceInterface
from .navigation_client import NavigationClient

class MainStateMachine(Node):
    def __init__(self):
        super().__init__('main_state_machine')
        
        self.voice = VoiceInterface()
        self.nav = NavigationClient()
        
        # [수정] NavigationClient가 통신을 계속 유지하도록 별도 스레드에서 spin 실행
        self.nav_thread = threading.Thread(target=rclpy.spin, args=(self.nav,), daemon=True)
        self.nav_thread.start()
        
        self.is_running = True
        self.emergency_stop = False
        
        self.destinations = {
            "point_a": ["A", "에이", "일번", "첫 번째", "출발지"],
            "point_b": ["B", "비", "이번", "두 번째", "목적지"]
        }
        self.yes_words = ["맞아", "그래", "네", "응", "어", "출발", "가자", "확인"]

        self.input_thread = threading.Thread(target=self.check_keyboard_input)
        self.input_thread.daemon = True
        self.input_thread.start()

        self.get_logger().info("=== 시스템 준비 완료 (Enter를 누르세요) ===")
        self.main_control_logic()

    def check_keyboard_input(self):
        while self.is_running:
            if sys.stdin in select.select([sys.stdin], [], [], 0.1)[0]:
                sys.stdin.readline()
                self.emergency_stop = True

    def main_control_logic(self):
        while rclpy.ok():
            self.emergency_stop = False
            print("\n[대기 모드] 안내를 시작하려면 엔터를 누르세요...", flush=True)
            
            while not self.emergency_stop:
                time.sleep(0.1)
            
            self.emergency_stop = False 
            self.voice.speak("안녕하세요. 어디로 안내해 드릴까요?")
            
            user_input = self.voice.listen()
            if not user_input:
                self.voice.speak("잘 듣지 못했습니다. 다시 시도해 주세요.")
                continue

            target_key = None
            target_keywords = []
            for key, keywords in self.destinations.items():
                if any(w in user_input.upper() for w in keywords):
                    target_key = key
                    target_keywords = keywords
                    break
            
            if target_key:
                display_name = "에이" if "a" in target_key else "비"
                self.voice.speak(f"{display_name} 지점으로 안내할까요?")
                confirm = self.voice.listen()
                
                is_confirmed = (
                    any(w in confirm for w in self.yes_words) or 
                    any(w in confirm.upper() for w in target_keywords) or
                    self.emergency_stop
                )

                if is_confirmed:
                    self.emergency_stop = False
                    self.run_navigation(target_key, display_name)
                else:
                    self.voice.speak("취소되었습니다.")
            else:
                self.voice.speak("등록되지 않은 장소입니다.")

    def run_navigation(self, target_key, display_name):
        """실제 로봇 주행 전 서버 연결을 먼저 확인"""
        # [수정] 서버 연결을 먼저 시도하고 성공 시에만 안내 멘트 시작
        success = self.nav.send_goal(target_key)
        
        if success:
            self.voice.speak(f"{display_name} 지점으로 안내를 시작합니다. 손잡이를 잡아주세요.")
            self.voice.speak("앞으로 직진합니다.")
            
            while rclpy.ok():
                if self.emergency_stop:
                    self.voice.speak("안내를 중단합니다.")
                    # Nav2 취소 로직은 추후 추가 가능
                    break
                time.sleep(0.5)
                # TODO: 여기에 도착 여부 판단(is_goal_reached) 추가 가능
        else:
            self.voice.speak("서버 연결에 실패했습니다. 로봇 상태를 확인해 주세요.")

def main(args=None):
    rclpy.init(args=args)
    try:
        node = MainStateMachine()
    except KeyboardInterrupt:
        pass
    finally:
        rclpy.shutdown()

if __name__ == '__main__':
    main()